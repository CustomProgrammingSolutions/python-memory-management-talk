<!DOCTYPE html>
<html>
  <head>
    <title>Memory management in Python - Janis Lesinskis</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

table {
    border-collapse: collapse;
}
th, td {
    padding: 5px;
    border: 1px solid red;
}

      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Memory management in Python

Janis Lesinskis

https://github.com/customprogrammingsolutions/python-memory-management-talk

![CPS](CPS-logo-with-text-main.svg)

---

# Python to RAM

1. ![Python logo](python-logo-master-v3-TM.png)
2. ???
3. ![RAM chip](RAM.jpg)

???

In this talk we will mostly cover the ??? part.

Images:
https://www.python.org/community/logos/
https://en.wikipedia.org/wiki/DDR_SDRAM#/media/File:Generic_DDR_Memory_(Xytram).jpg


---

# First some background

We are going to assume we are on a Von Neumann Architecture

What this means is that RAM is essentially addressable.


---

# What is a variable?

* Symbolic name
* Storage location

???

If more than one symbolic name is located at the same storage location this is referred to as [aliasing](https://en.wikipedia.org/wiki/Aliasing_(computing)). 

---

# Variables

```python
>>> foo = [1,2,3]
>>> id(foo)
140249342557576
```

* `foo` is the symbolic name
* `id(foo)` is where foo is stored at
* `[1,2,3]` is what we find there

---

# Pythontutor

There's a great site for getting intuition into how variables work in Python: http://pythontutor.com/

Let's have a look at this example:

```python
a = 1
b = "abc"
c = [a, b]
```

---

# How many variables did we need to assign?

In the previous example we saw that we needed to assign 3 variables.

But what about this:

---

# Stack frames

We can set aside some memory for storing variables, we also have to set aside memory for handling function calls.

When we create a function we have to put aside the memory for all the variables inside it as well as the function call machinery .

This is most easily achieved with a stack based structure (but not the only way it can be done)

---

# Stack frames in Python

CPython has the notion of a Stack frame defines in [`PyFrameObject`](https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyFrameObject) and evaluates them in using [`PyEval_EvalFrameEx`](https://docs.python.org/3/c-api/veryhigh.html?highlight=pyframeobject#c.PyEval_EvalFrameEx)


???

This `PyEval_EvalFrameEx` function is the evaluation function for Python, with PEP 

---

# Garbage collection

Python is a managed language, you don't have to manually manage memory as you would in say C++ or Rust.

When you create a variable Python will set aside the memory needed to store that variable.
When variables are not needed anymore Python has to reclaim the memory.

How this works is implementation specific CPython has a simple reference count based approach, chosen primarily for maximum compatibility.
(Jython uses the JVM memory management, PyPy has a different strategy)

---

# Python's reference counter

Each time you make reference to a variable the reference count for the variable is incremented, when that count gets to zero then you have nothing referring to that variable anymore* at which point the item's `__del__` method gets called and the memory can be reused.

*There _are_ ways around this if you need them, see [weakref](https://docs.python.org/3/library/weakref.html) for example.

???

This is good reading for how this all works: https://docs.python.org/3/extending/extending.html#reference-counts

If you make C extensions you have to manually increment and decrement references.

---

# What about cycles?

Unfortunately a purely reference counting based implementation can't break cycles.

This is why there's a cycle detector in CPython that periodically runs:

https://docs.python.org/3/library/gc.html

???

There's an edge case in older versions of Python where the cycle detector can't actually free the memory, this is when objects define `__del__` in such a way that the interpreter cannot safely pick which to run first since `__del__` can contain arbitraty code. When this happens the objects get placed in [`gc.garbage`](http://docs.python.org/library/gc.html#gc.garbage) to be dealt with by the programmer. Or just forgotten entirely... This is where things like https://pythonhosted.org/Pympler/ are useful to detect leaked memory.

Since PEP 442 https://www.python.org/dev/peps/pep-0442/ which got included in Python 3.4 the number of cases in which this comes up is far smaller now.
You will likely only run into this in in cases where you define a `__del__` operator via the C-API. (I'd be curious to hear of any other cases)

---

# Cycle example

```python
"""Example of a cyclic reference that can be resolved in both python3 and python2"""
import gc

class A:
    def __init__ (self, name):
        self.name = name
        self.other = None
    def set_other(self, other):
        self.other = other
    def __repr__(self):
        return "A({})".format(self.name)

a1 = A("first")
a2 = A("second")
a3 = A("third")
a1.set_other(a2)
a2.set_other(a3)
a3.set_other(a1)

a1 = a2 = a3 = None
n = gc.collect()
print("Number of unreachable objects {}".format(n)) # 6 items get freed
```

???

`gc.collect` calls a run of the cycle detector and returns the number of items that were freed from the run. In this case it was 6.

---

# Python Objects (part 1)

Python is an "Object Oriented Language", which in this case means that almost every variable is accessible via a similar interface.

Python has the notion of a [data model](https://docs.python.org/3/reference/datamodel.html), where objects are the abstraction Python uses for data.

If you look around the source code you'll see these `PyObjects` all over the place. All these `PyObjects` are allocated in a chunk of memory that people may informally refer to as "the heap".

---

# CPython Objects - where (part 2)

[Since Python 2.3](https://docs.python.org/2.3/whatsnew/section-pymalloc.html) CPython has used some functions very similar to the C malloc and free functions to allocate the memory in which objects are stored. These functions are modified to be more suitable for allocating the Python objects we commonly see.

What malloc does is *alloc*ates a space in *m*emory for which a variable can be placed and gives you the pointer to where that space starts.

In CPython when you do `id(something)` what you are seeing is the memory address of where `something` resides:

```python
>>> foo = 123
>>> id(foo)
10923328
```

???
Most of the time when you store different items they will end up at different addresses, but not always.

Some items commonly used items are optimized to just be in one place and will therefore have a reference to that place.

For example:
```python
>>> c = None
>>> id(c)
10748000
>>> d = None
>>> id(d)
10748000
```

`None` is always stored at the same address

Small integers are cached

```python
>>> e = 5
>>> id(e)
10919552
>>> f = 5
>>> id(f)
10919552

```

"Large" integers however are not:

```python
>>> a = 12345
>>> id(a)
140498856595248
>>> b = 12345
>>> id(b)
140498834051248
```

Note how the small integers and values like `None` are in a completely different area of memory to the non-cached variables.

---

# CPython objects - what (part 3)

So we know where the objects end up in memory but what gets put there?

The source code is here:
https://github.com/python/cpython/blob/master/Include/object.h

A comment from the source:

    Objects are structures allocated on the heap.  Special rules apply to
    the use of objects to ensure they are properly garbage-collected.
    Objects are never allocated statically or on the stack; they must be
    accessed through special macros and functions only.

    An object has a 'reference count' that is increased or decreased when a
    pointer to the object is copied or deleted; when the reference count
    reaches zero there are no references to the object left and it can be
    removed from the heap.

---

# How variables are implemented

https://github.com/python/cpython/blob/b2984ab9a7c458f8b7ed8978c0c95b109116895d/Include/object.h#L101:
```c
/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
typedef struct _object {
    _PyObject_HEAD_EXTRA
    Py_ssize_t ob_refcnt;
    struct _typeobject *ob_type;
} PyObject;
```

This gives us the base from which everything else is built.
This is a placeholder into which we can store arbitrary variables.

???

This provides for the reference counted memory management of anything stored within it.

`_PyObject_HEAD_EXTRA` deals with a debug tracing feature and is often #defined away as nothing.

---

# Python objects, what's in them?

Because everything has this similar interface to access we have some nice tools like `dir` to see what's inside an object:

```python
>>> a = [1,2,3]
>>> dir(a)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```

This tells us which methods we can call on `a`. All the double underscore or "dunder" methods as they are known have special meaning in terms of the interface they provide.

`__len__` lets us find the length of the item via the `len` function.
```python
>>> len(a)
3
```

???

`dir` is defined in the C source here https://github.com/python/cpython/blob/b2984ab9a7c458f8b7ed8978c0c95b109116895d/Objects/object.c#L1479-L1487

`len(a)` just calls `a.__len__`.

---

# Functions have this interface too

Functions are also accessible via this same object interface:

```python
>>> def foo():
...     print("bar")
... 
>>> dir(foo)
['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```

This means we can pass functions around just as easily as variables.

`__call__` is part of the function interface, something not in the list interface.

???

---

# How variables end up layed out in heap memory
https://github.com/python/cpython/blob/b2984ab9a7c458f8b7ed8978c0c95b109116895d/Include/object.h#L460-L477
```c
/* The *real* layout of a type object when allocated on the heap */
typedef struct _heaptypeobject {
    /* Note: there's a dependency on the order of these members
       in slotptr() in typeobject.c . */
    PyTypeObject ht_type;
    PyAsyncMethods as_async;
    PyNumberMethods as_number;
    PyMappingMethods as_mapping;
    PySequenceMethods as_sequence; /* as_sequence comes after as_mapping,
                                      so that the mapping wins when both
                                      the mapping and the sequence define
                                      a given operator (e.g. __getitem__).
                                      see add_operators() in typeobject.c . */
    PyBufferProcs as_buffer;
    PyObject *ht_name, *ht_slots, *ht_qualname;
    struct _dictkeysobject *ht_cached_keys;
    /* here are optional user slots, followed by the members. */
} PyHeapTypeObject;
```

---

# Questions?

---
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
